{
  "version": 3,
  "sources": ["../../lezer-tree/src/tree.ts", "../../lezer/src/stack.ts", "../../lezer/src/token.ts", "../../lezer/src/decode.ts", "../../lezer/src/parse.ts"],
  "sourcesContent": ["/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node set.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lezer/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#tree.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#tree.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether is is a [top node](#tree.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#tree.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#tree.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) src[0].set(props, src[1])\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          add[0].set(newProps, add[1])\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nexport class Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number\n  ) {}\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, true)\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number): false | void,\n    leave?(type: NodeType, from: number, to: number): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor();;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length, 0)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\n// For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\nfunction withHash(tree: Tree, hash: number) {\n  if (hash) (tree as any).contextHash = hash\n  return tree\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly set: NodeSet,\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, after: number) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != After.None) {\n        let start = buffer[i + 1], end = buffer[i + 2]\n        if (dir > 0) {\n          if (end > after) pick = i\n          if (end > after) break\n        } else {\n          if (start < after) pick = i\n          if (end >= after) break\n        }\n      } else {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n}\n\nconst enum After { None = -1e8 }\n\n/// A syntax node provides an immutable pointer at a given node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#tree.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that starts at or after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that ends at or before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#tree.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#tree.NodeProp.name) or a [group\n  /// name](#tree.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#tree.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nclass TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly from: number,\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get to() { return this.from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, after: number, full = false): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from\n        if (after != After.None && (dir < 0 ? start >= after : start + next.length <= after))\n          continue\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == After.None ? After.None : after - start)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent)\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after)\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null\n      i = parent.index + dir\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, After.None) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, After.None) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos) }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, after: number): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.context.start)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, After.None) }\n  get lastChild() { return this.child(-1, After.None) }\n\n  childAfter(pos: number) { return this.child(1, pos) }\n  childBefore(pos: number) { return this.child(-1, pos) }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, After.None))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(node: TreeNode | BufferNode, readonly full = false) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enter(dir: 1 | -1, after: number) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.buffer.start)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enter(1, After.None) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enter(-1, After.None) }\n\n  /// Move the cursor to the first child that starts at or after `pos`.\n  childAfter(pos: number) { return this.enter(1, pos) }\n\n  /// Move to the last child that ends at or before `pos`.\n  childBefore(pos: number) { return this.enter(-1, pos) }\n\n  /// Move the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, After.None, this.full))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, After.None))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, After.None, this.full)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1) {\n    if (this.enter(dir, After.None)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n  next() { return this.move(1) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev() { return this.move(-1) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break\n      if (this.from == this.to ||\n          (side < 1 ? this.from >= pos : this.from > pos) ||\n          (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent()\n        break\n      }\n    }\n    return this\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch))\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n\n  let contextHash = 0\n\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    let startPos = start - parentStart\n    if (size < 0) {\n      if (size == -1) { // Reused node\n        children.push(reused[id])\n        positions.push(startPos)\n      } else { // Context change\n        contextHash = id\n      }\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index, inRepeat)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat])\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next()\n        else takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n      }\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength,\n                            end - start, contextHash)\n      else\n        node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number, inRepeat: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (id == inRepeat) return index\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number,\n                      length: number, contextHash: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n\n/// The [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges)\n/// method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\nconst enum Open { Start = 1, End = 2 }\n\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nexport class TreeFragment {\n  constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    readonly from: number,\n    /// The end of the unchanged range.\n    readonly to: number,\n    /// The tree that this fragment is based on.\n    readonly tree: Tree,\n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    readonly offset: number,\n    private open: number\n  ) {}\n\n  get openStart() { return (this.open & Open.Start) > 0 }\n\n  get openEnd() { return (this.open & Open.End) > 0 }\n\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments: readonly TreeFragment[], changes: readonly ChangedRange[], minGap = 128) {\n    if (!changes.length) return fragments\n    let result: TreeFragment[] = []\n    let fI = 1, nextF = fragments.length ? fragments[0] : null\n    let cI = 0, pos = 0, off = 0\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null\n      let nextPos = nextC ? nextC.fromA : 1e9\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut: TreeFragment | null = nextF\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off\n          cut = fFrom >= fTo ? null :\n            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off,\n                             (cI > 0 ? Open.Start : 0) | (nextC ? Open.End : 0))\n        }\n        if (cut) result.push(cut)\n        if (nextF.to > nextPos) break\n        nextF = fI < fragments.length ? fragments[fI++] : null\n      }\n      if (!nextC) break\n      pos = nextC.toA\n      off = nextC.toA - nextC.toB\n    }\n    return result\n  }\n\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n  static addTree(tree: Tree, fragments: readonly TreeFragment[] = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? Open.End : 0)]\n    for (let f of fragments) if (f.to > tree.length) result.push(f)\n    return result\n  }\n}\n\n/// Interface used to represent an in-progress parse, which can be\n/// moved forward piece-by-piece.\nexport interface PartialParse {\n  /// Advance the parse state by some amount.\n  advance(): Tree | null\n  /// The current parse position.\n  pos: number\n  /// Get the currently parsed content as a tree, even though the\n  /// parse hasn't finished yet.\n  forceFinish(): Tree\n}\n\n/// A parse context is an object providing additional information to the\n/// parser. It is passed through to nested parsers.\nexport interface ParseContext {\n  /// A set of fragments from a previous parse to be used for incremental\n  /// parsing. These should be aligned with the current document\n  /// (through a call to\n  /// [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges))\n  /// if any changes were made since they were produced. The parser\n  /// will try to reuse nodes from the fragments in the new parse,\n  /// greatly speeding up the parse when it can do so for most of the\n  /// document.\n  fragments?: readonly TreeFragment[]\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code units. Most (but not _all_)\n/// access, especially through `get`, will be sequential, so\n/// implementations can optimize for that.\nexport interface Input {\n  /// The end of the stream.\n  length: number\n  /// Get the code unit at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream.\n  get(pos: number): number\n  /// Returns the string between `pos` and the next newline character\n  /// or the end of the document. Not used by the built-in tokenizers,\n  /// but can be useful in custom tokenizers or completely custom\n  /// parsers.\n  lineAfter(pos: number): string\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `Input` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): Input\n}\n\n// Creates an `Input` that is backed by a single, flat string.\nexport function stringInput(input: string): Input { return new StringInput(input) }\n\nclass StringInput implements Input {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n\n  lineAfter(pos: number) {\n    if (pos < 0) return \"\"\n    let end = this.string.indexOf(\"\\n\", pos)\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length))\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringInput(this.string, at) }\n}\n", "import {Action, Term, StateFlag, ParseState, Seq} from \"./constants\"\nimport {Parse, ContextTracker} from \"./parse\"\nimport {Tree, TreeBuffer, BufferCursor} from \"lezer-tree\"\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nexport class Stack {\n  /// @internal\n  constructor(\n    /// A the parse that this stack is part of @internal\n    readonly p: Parse,\n    /// Holds state, pos, value stack pos (15 bits array index, 15 bits\n    /// buffer index) triplets for all but the top state\n    /// @internal\n    readonly stack: number[],\n    /// The current parse state @internal\n    public state: number,\n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    public reducePos: number,\n    /// The input position up to which this stack has parsed.\n    public pos: number,\n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    public score: number,\n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    readonly buffer: number[],\n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    readonly bufferBase: number,\n    /// @internal\n    public curContext: StackContext | null,\n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    readonly parent: Stack | null\n  ) {}\n\n  /// @internal\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`\n  }\n\n  // Start an empty stack\n  /// @internal\n  static start(p: Parse, state: number, pos = 0) {\n    let cx = p.parser.context\n    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null)\n  }\n\n  /// The stack's current [context](#lezer.ContextTracker) value, if\n  /// any. Its type will depend on the context tracker's type\n  /// parameter, or it will be `null` if there is no context\n  /// tracker.\n  get context() { return this.curContext ? this.curContext.context : null }\n\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /// @internal\n  pushState(state: number, start: number) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length)\n    this.state = state\n  }\n\n  // Apply a reduce action\n  /// @internal\n  reduce(action: number) {\n    let depth = action >> Action.ReduceDepthShift, type = action & Action.ValueMask\n    let {parser} = this.p\n\n    let dPrec = parser.dynamicPrecedence(type)\n    if (dPrec) this.score += dPrec\n\n    if (depth == 0) {\n      // Zero-depth reductions are a special casethey add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true)\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos)\n      this.reduceContext(type)\n      return\n    }\n\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - ((depth - 1) * 3) - (action & Action.StayFlag ? 6 : 0)\n    let start = this.stack[base - 2]\n    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase\n    // Store normal terms or `R -> R R` repeat reductions\n    if (type < parser.minRepeatTerm || (action & Action.RepeatFlag)) {\n      let pos = parser.stateFlag(this.state, StateFlag.Skipped) ? this.pos : this.reducePos\n      this.storeNode(type, start, pos, count + 4, true)\n    }\n    if (action & Action.StayFlag) {\n      this.state = this.stack[base]\n    } else {\n      let baseStateID = this.stack[base - 3]\n      this.state = parser.getGoto(baseStateID, type, true)\n    }\n    while (this.stack.length > base) this.stack.pop()\n    this.reduceContext(type)\n  }\n\n  // Shift a value into the buffer\n  /// @internal\n  storeNode(term: number, start: number, end: number, size = 4, isReduce = false) {\n    if (term == Term.Err) { // Try to omit/merge adjacent error nodes\n      let cur: Stack | null = this, top = this.buffer.length\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase\n        cur = cur.parent\n      }\n      if (top > 0 && cur.buffer[top - 4] == Term.Err && cur.buffer[top - 1] > -1) {\n        if (start == end) return\n        if (cur.buffer[top - 2] >= start) { cur.buffer[top - 2] = end; return }\n      }\n    }\n\n    if (!isReduce || this.pos == end) { // Simple case, just append\n      this.buffer.push(term, start, end, size)\n    } else { // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length\n      if (index > 0 && this.buffer[index - 4] != Term.Err) while (index > 0 && this.buffer[index - 2] > end) {\n        // Move this record forward\n        this.buffer[index] = this.buffer[index - 4]\n        this.buffer[index + 1] = this.buffer[index - 3]\n        this.buffer[index + 2] = this.buffer[index - 2]\n        this.buffer[index + 3] = this.buffer[index - 1]\n        index -= 4\n        if (size > 4) size -= 4\n      }\n      this.buffer[index] = term\n      this.buffer[index + 1] = start\n      this.buffer[index + 2] = end\n      this.buffer[index + 3] = size\n    }\n  }\n\n  // Apply a shift action\n  /// @internal\n  shift(action: number, next: number, nextEnd: number) {\n    if (action & Action.GotoFlag) {\n      this.pushState(action & Action.ValueMask, this.pos)\n    } else if ((action & Action.StayFlag) == 0) { // Regular shift\n      let start = this.pos, nextState = action, {parser} = this.p\n      if (nextEnd > this.pos || next <= parser.maxNode) {\n        this.pos = nextEnd\n        if (!parser.stateFlag(nextState, StateFlag.Skipped)) this.reducePos = nextEnd\n      }\n      this.pushState(nextState, start)\n      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4)\n      this.shiftContext(next)\n    } else { // Shift-and-stay, which means this is a skipped token\n      if (next <= this.p.parser.maxNode) this.buffer.push(next, this.pos, nextEnd, 4)\n      this.pos = nextEnd\n    }\n  }\n\n  // Apply an action\n  /// @internal\n  apply(action: number, next: number, nextEnd: number) {\n    if (action & Action.ReduceFlag) this.reduce(action)\n    else this.shift(action, next, nextEnd)\n  }\n\n  // Add a prebuilt node into the buffer. This may be a reused node or\n  // the result of running a nested parser.\n  /// @internal\n  useNode(value: Tree | TreeBuffer, next: number) {\n    let index = this.p.reused.length - 1\n    if (index < 0 || this.p.reused[index] != value) {\n      this.p.reused.push(value)\n      index++\n    }\n    let start = this.pos\n    this.reducePos = this.pos = start + value.length\n    this.pushState(next, start)\n    this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */)\n    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this))\n  }\n\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /// @internal\n  split() {\n    let parent: Stack | null = this\n    let off = parent.buffer.length\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4\n    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent\n    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos,\n                     this.score, buffer, base, this.curContext, parent)\n  }\n\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /// @internal\n  recoverByDelete(next: number, nextEnd: number) {\n    let isNode = next <= this.p.parser.maxNode\n    if (isNode) this.storeNode(next, this.pos, nextEnd)\n    this.storeNode(Term.Err, this.pos, nextEnd, isNode ? 8 : 4)\n    this.pos = this.reducePos = nextEnd\n    this.score -= Recover.Token\n  }\n\n  /// Check if the given term would be able to be shifted (optionally\n  /// after some reductions) on this stack. This can be useful for\n  /// external tokenizers that want to make sure they only provide a\n  /// given token when it applies.\n  canShift(term: number) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.p.parser.stateSlot(sim.top, ParseState.DefaultReduce) || this.p.parser.hasAction(sim.top, term)\n      if ((action & Action.ReduceFlag) == 0) return true\n      if (action == 0) return false\n      sim.reduce(action)\n    }\n  }\n\n  /// Find the start position of the rule that is currently being parsed.\n  get ruleStart() {\n    for (let state = this.state, base = this.stack.length;;) {\n      let force = this.p.parser.stateSlot(state, ParseState.ForcedReduce)\n      if (!(force & Action.ReduceFlag)) return 0\n      base -= 3 * (force >> Action.ReduceDepthShift)\n      if ((force & Action.ValueMask) < this.p.parser.minRepeatTerm)\n        return this.stack[base + 1]\n      state = this.stack[base]\n    }\n  }\n\n  /// Find the start position of an instance of any of the given term\n  /// types, or return `null` when none of them are found.\n  ///\n  /// **Note:** this is only reliable when there is at least some\n  /// state that unambiguously matches the given rule on the stack.\n  /// I.e. if you have a grammar like this, where the difference\n  /// between `a` and `b` is only apparent at the third token:\n  ///\n  ///     a { b | c }\n  ///     b { \"x\" \"y\" \"x\" }\n  ///     c { \"x\" \"y\" \"z\" }\n  ///\n  /// Then a parse state after `\"x\"` will not reliably tell you that\n  /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n  /// for either of those two rules (assuming that `a` isn't part of\n  /// some rule that includes other things starting with `\"x\"`).\n  ///\n  /// When `before` is given, this keeps scanning up the stack until\n  /// it finds a match that starts before that position.\n  ///\n  /// Note that you have to be careful when using this in tokenizers,\n  /// since it's relatively easy to introduce data dependencies that\n  /// break incremental parsing by using this method.\n  startOf(types: readonly number[], before?: number) {\n    let state = this.state, frame = this.stack.length, {parser} = this.p\n    for (;;) {\n      let force = parser.stateSlot(state, ParseState.ForcedReduce)\n      let depth = force >> Action.ReduceDepthShift, term = force & Action.ValueMask\n      if (types.indexOf(term) > -1) {\n        let base = frame - (3 * (force >> Action.ReduceDepthShift)), pos = this.stack[base + 1]\n        if (before == null || before > pos) return pos\n      }\n      if (frame == 0) return null\n      if (depth == 0) {\n        frame -= 3\n        state = this.stack[frame]\n      } else {\n        frame -= 3 * (depth - 1)\n        state = parser.getGoto(this.stack[frame - 3], term, true)\n      }\n    }\n  }\n\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /// @internal\n  recoverByInsert(next: number): Stack[] {\n    if (this.stack.length >= Recover.MaxInsertStackDepth) return []\n\n    let nextStates = this.p.parser.nextStates(this.state)\n    if (nextStates.length > Recover.MaxNext << 1 || this.stack.length >= Recover.DampenInsertStackDepth) {\n      let best = []\n      for (let i = 0, s; i < nextStates.length; i += 2) {\n        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n          best.push(nextStates[i], s)\n      }\n      if (this.stack.length < Recover.DampenInsertStackDepth)\n        for (let i = 0; best.length < Recover.MaxNext << 1 && i < nextStates.length; i += 2) {\n          let s = nextStates[i + 1]\n          if (!best.some((v, i) => (i & 1) && v == s)) best.push(nextStates[i], s)\n        }\n      nextStates = best\n    }\n    let result: Stack[] = []\n    for (let i = 0; i < nextStates.length && result.length < Recover.MaxNext; i += 2) {\n      let s = nextStates[i + 1]\n      if (s == this.state) continue\n      let stack = this.split()\n      stack.storeNode(Term.Err, stack.pos, stack.pos, 4, true)\n      stack.pushState(s, this.pos)\n      stack.shiftContext(nextStates[i])\n      stack.score -= Recover.Token\n      result.push(stack)\n    }\n    return result\n  }\n\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /// @internal\n  forceReduce() {\n    let reduce = this.p.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if ((reduce & Action.ReduceFlag) == 0) return false\n    if (!this.p.parser.validAction(this.state, reduce)) {\n      this.storeNode(Term.Err, this.reducePos, this.reducePos, 4, true)\n      this.score -= Recover.Reduce\n    }\n    this.reduce(reduce)\n    return true\n  }\n\n  /// @internal\n  forceAll() {\n    while (!this.p.parser.stateFlag(this.state, StateFlag.Accepting) && this.forceReduce()) {}\n    return this\n  }\n\n  /// Check whether this state has no further actions (assumed to be a direct descendant of the\n  /// top state, since any other states must be able to continue\n  /// somehow). @internal\n  get deadEnd() {\n    if (this.stack.length != 3) return false\n    let {parser} = this.p\n    return parser.data[parser.stateSlot(this.state, ParseState.Actions)] == Seq.End &&\n      !parser.stateSlot(this.state, ParseState.DefaultReduce)\n  }\n\n  /// Restart the stack (put it back in its start state). Only safe\n  /// when this.stack.length == 3 (state is directly below the top\n  /// state). @internal\n  restart() {\n    this.state = this.stack[0]\n    this.stack.length = 0\n  }\n\n  /// @internal\n  sameState(other: Stack) {\n    if (this.state != other.state || this.stack.length != other.stack.length) return false\n    for (let i = 0; i < this.stack.length; i += 3)\n      if (this.stack[i] != other.stack[i]) return false\n    return true\n  }\n\n  /// Get the parser used by this stack.\n  get parser() { return this.p.parser }\n\n  /// Test whether a given dialect (by numeric ID, as exported from\n  /// the terms file) is enabled.\n  dialectEnabled(dialectID: number) { return this.p.parser.dialect.flags[dialectID] }\n\n  private shiftContext(term: number) {\n    if (this.curContext)\n      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this))\n  }\n\n  private reduceContext(term: number) {\n    if (this.curContext)\n      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this))\n  }\n\n  /// @internal\n  emitContext() {\n    let cx = this.curContext!\n    if (!cx.tracker.strict) return\n    let last = this.buffer.length - 1\n    if (last < 0 || this.buffer[last] != -2)\n      this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2)\n  }\n\n  private updateContext(context: any) {\n    if (context != this.curContext!.context) {\n      let newCx = new StackContext(this.curContext!.tracker, context)\n      if (newCx.hash != this.curContext!.hash) this.emitContext()\n      this.curContext = newCx\n    }\n  }\n}\n\nclass StackContext {\n  readonly hash: number\n  constructor(readonly tracker: ContextTracker<any>, readonly context: any) {\n    this.hash = tracker.hash(context)\n  }\n}\n\nexport const enum Recover {\n  Token = 200,\n  Reduce = 100,\n  MaxNext = 4,\n  MaxInsertStackDepth = 300,\n  DampenInsertStackDepth = 120\n}\n\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  top: number\n  rest: number[]\n  offset: number\n\n  constructor(readonly stack: Stack) {\n    this.top = stack.state\n    this.rest = stack.stack\n    this.offset = this.rest.length\n  }\n\n  reduce(action: number) {\n    let term = action & Action.ValueMask, depth = action >> Action.ReduceDepthShift\n    if (depth == 0) {\n      if (this.rest == this.stack.stack) this.rest = this.rest.slice()\n      this.rest.push(this.top, 0, 0)\n      this.offset += 3\n    } else {\n      this.offset -= (depth - 1) * 3\n    }\n    let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true)\n    this.top = goto\n  }\n}\n\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nexport class StackBufferCursor implements BufferCursor {\n  buffer: number[]\n\n  constructor(public stack: Stack, public pos: number, public index: number) {\n    this.buffer = stack.buffer\n    if (this.index == 0) this.maybeNext()\n  }\n\n  static create(stack: Stack) {\n    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length)\n  }\n\n  maybeNext() {\n    let next = this.stack.parent\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase\n      this.stack = next\n      this.buffer = next.buffer\n    }\n  }\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  next() {\n    this.index -= 4\n    this.pos -= 4\n    if (this.index == 0) this.maybeNext()\n  }\n\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index)\n  }\n}\n", "import {Input} from \"lezer-tree\"\nimport {Stack} from \"./stack\"\n\n/// Tokenizers write the tokens they read into instances of this class.\nexport class Token {\n  /// The start of the token. This is set by the parser, and should not\n  /// be mutated by the tokenizer.\n  start = -1\n  /// This starts at -1, and should be updated to a term id when a\n  /// matching token is found.\n  value = -1\n  /// When setting `.value`, you should also set `.end` to the end\n  /// position of the token. (You'll usually want to use the `accept`\n  /// method.)\n  end = -1\n\n  /// Accept a token, setting `value` and `end` to the given values.\n  accept(value: number, end: number) {\n    this.value = value\n    this.end = end\n  }\n}\n\nexport interface Tokenizer {\n  token(input: Input, token: Token, stack: Stack): void\n  contextual: boolean\n  fallback: boolean\n  extend: boolean\n}\n\n/// @internal\nexport class TokenGroup implements Tokenizer {\n  contextual!: boolean\n  fallback!: boolean\n  extend!: boolean\n\n  constructor(readonly data: Readonly<Uint16Array>, readonly id: number) {}\n\n  token(input: Input, token: Token, stack: Stack) { readToken(this.data, input, token, stack, this.id) }\n}\n\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false\n\ninterface ExternalOptions {\n  /// When set to true, mark this tokenizer as depending on the\n  /// current parse stack, which prevents its result from being cached\n  /// between parser actions at the same positions.\n  contextual?: boolean,\n  /// By defaults, when a tokenizer returns a token, that prevents\n  /// tokenizers with lower precedence from even running. When\n  /// `fallback` is true, the tokenizer is allowed to run when a\n  /// previous tokenizer returned a token that didn't match any of the\n  /// current state's actions.\n  fallback?: boolean\n  /// When set to true, tokenizing will not stop after this tokenizer\n  /// has produced a token. (But it will still fail to reach this one\n  /// if a higher-precedence tokenizer produced a token.)\n  extend?: boolean\n}\n\n/// Exports that are used for `@external tokens` in the grammar should\n/// export an instance of this class.\nexport class ExternalTokenizer {\n  /// @internal\n  contextual: boolean\n  /// @internal\n  fallback: boolean\n  /// @internal\n  extend: boolean\n\n  /// Create a tokenizer. The first argument is the function that,\n  /// given an input stream and a token object,\n  /// [fills](#lezer.Token.accept) the token object if it recognizes a\n  /// token. `token.start` should be used as the start position to\n  /// scan from.\n  constructor(\n    /// @internal\n    readonly token: (input: Input, token: Token, stack: Stack) => void,\n    options: ExternalOptions = {}\n  ) {\n    this.contextual = !!options.contextual\n    this.fallback = !!options.fallback\n    this.extend = !!options.extend\n  }\n}\n\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data: Readonly<Uint16Array>,\n                   input: Input,\n                   token: Token,\n                   stack: Stack,\n                   group: number) {\n  let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect\n  scan: for (let pos = token.start;;) {\n    if ((groupMask & data[state]) == 0) break\n    let accEnd = data[state + 1]\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i]\n      if (dialect.allows(term) &&\n          (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {\n        token.accept(term, pos)\n        break\n      }\n    }\n    let next = input.get(pos++)\n    // Do a binary search on the state's edges\n    for (let low = 0, high = data[state + 2]; low < high;) {\n      let mid = (low + high) >> 1\n      let index = accEnd + mid + (mid << 1)\n      let from = data[index], to = data[index + 1]\n      if (next < from) high = mid\n      else if (next >= to) low = mid + 1\n      else { state = data[index + 2]; continue scan }\n    }\n    break\n  }\n}\n", "// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\n\nimport {Encode} from \"./constants\"\n\nexport function decodeArray<T extends {[i: number]: number} = Uint16Array>(\n  input: string | T,\n  Type: {new (n: number): T} = Uint16Array as any\n): T {\n  if (typeof input != \"string\") return input\n  let array: T | null = null\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0\n    for (;;) {\n      let next = input.charCodeAt(pos++), stop = false\n      if (next == Encode.BigValCode) { value = Encode.BigVal; break }\n      if (next >= Encode.Gap2) next--\n      if (next >= Encode.Gap1) next--\n      let digit = next - Encode.Start\n      if (digit >= Encode.Base) { digit -= Encode.Base; stop = true }\n      value += digit\n      if (stop) break\n      value *= Encode.Base\n    }\n    if (array) array[out++] = value\n    else array = new Type(value)\n  }\n  return array!\n}\n", "import {DefaultBufferLength, Tree, TreeBuffer, TreeFragment, NodeSet, NodeType, NodeProp, NodePropSource,\n        Input, stringInput, PartialParse, ParseContext} from \"lezer-tree\"\nimport {Stack, StackBufferCursor} from \"./stack\"\nimport {Action, Specialize, Term, Seq, StateFlag, ParseState, File} from \"./constants\"\nimport {Token, Tokenizer, TokenGroup, ExternalTokenizer} from \"./token\"\nimport {decodeArray} from \"./decode\"\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG!)\n\nlet stackIDs: WeakMap<Stack, string> | null = null\n\n/// Used to configure a [nested parse](#lezer.Parser.withNested).\nexport type NestedParserSpec = {\n  /// The inner parser. Will be passed the input,\n  /// [clipped](#lezer.Input.clip) to the size of the parseable\n  /// region, the start position of the inner region as `startPos`,\n  /// and an optional array of tree fragments from a previous parse\n  /// that can be reused.\n  ///\n  /// When this property isn't given, the inner region is simply\n  /// skipped over intead of parsed.\n  startParse?: (input: Input, startPos: number, context: ParseContext) => PartialParse\n  /// When given, an additional node will be wrapped around the\n  /// part of the tree produced by this inner parse.\n  wrapType?: NodeType | number\n  /// When given, this will be called with the token that ends the\n  /// inner region. It can return `false` to cause a given end token\n  /// to be ignored.\n  filterEnd?(endToken: string): boolean\n}\n\n/// This type is used to specify a nested parser. It may directly be a\n/// nested parse [spec](#lezer.NestedParseSpec), or a function that,\n/// given an input document and a stack, returns such a spec or `null`\n/// to indicate that the nested parse should not happen (and the\n/// grammar's fallback expression should be used).\nexport type NestedParser = NestedParserSpec | ((input: Input, stack: Stack) => NestedParserSpec | null)\n\nfunction cutAt(tree: Tree, pos: number, side: 1 | -1) {\n  let cursor = tree.cursor(pos)\n  for (;;) {\n    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {\n      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n        return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5))\n      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break\n      if (!cursor.parent()) return side < 0 ? 0 : tree.length\n    }\n  }\n}\n\nclass FragmentCursor {\n  i = 0\n  fragment: TreeFragment | null = null\n  safeFrom = -1\n  safeTo = -1\n  trees: Tree[] = []\n  start: number[] = []\n  index: number[] = []\n  nextStart!: number\n\n  constructor(readonly fragments: readonly TreeFragment[]) {\n    this.nextFragment()\n  }\n\n  nextFragment() {\n    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++]\n    if (fr) {\n      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from\n      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to\n      while (this.trees.length) { this.trees.pop(); this.start.pop(); this.index.pop() }\n      this.trees.push(fr.tree)\n      this.start.push(-fr.offset)\n      this.index.push(0)\n      this.nextStart = this.safeFrom\n    } else {\n      this.nextStart = 1e9\n    }\n  }\n\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos: number): Tree | TreeBuffer | null {\n    if (pos < this.nextStart) return null\n    while (this.fragment && this.safeTo <= pos) this.nextFragment()\n    if (!this.fragment) return null\n\n    for (;;) {\n      let last = this.trees.length - 1\n      if (last < 0) { // End of tree\n        this.nextFragment()\n        return null\n      }\n      let top = this.trees[last], index = this.index[last]\n      if (index == top.children.length) {\n        this.trees.pop()\n        this.start.pop()\n        this.index.pop()\n        continue\n      }\n      let next = top.children[index]\n      let start = this.start[last] + top.positions[index]\n      if (start > pos) {\n        this.nextStart = start\n        return null\n      } else if (start == pos && start + next.length <= this.safeTo) {\n        return start == pos && start >= this.safeFrom ? next : null\n      }\n      if (next instanceof TreeBuffer) {\n        this.index[last]++\n        this.nextStart = start + next.length\n      } else {\n        this.index[last]++\n        if (start + next.length >= pos) { // Enter this node\n          this.trees.push(next)\n          this.start.push(start)\n          this.index.push(0)\n        }\n      }\n    }\n  }\n}\n\nclass CachedToken extends Token {\n  extended = -1\n  mask = 0\n  context = 0\n\n  clear(start: number) {\n    this.start = start\n    this.value = this.extended = -1\n  }\n}\n\nconst dummyToken = new Token\n\nclass TokenCache {\n  tokens: CachedToken[] = []\n  mainToken: Token = dummyToken\n\n  actions: number[] = []\n\n  constructor(parser: Parser) {\n    this.tokens = parser.tokenizers.map(_ => new CachedToken)\n  }\n\n  getActions(stack: Stack, input: Input) {\n    let actionIndex = 0\n    let main: Token | null = null\n    let {parser} = stack.p, {tokenizers} = parser\n\n    let mask = parser.stateSlot(stack.state, ParseState.TokenizerMask)\n    let context = stack.curContext ? stack.curContext.hash : 0\n    for (let i = 0; i < tokenizers.length; i++) {\n      if (((1 << i) & mask) == 0) continue\n      let tokenizer = tokenizers[i], token = this.tokens[i]\n      if (main && !tokenizer.fallback) continue\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n        this.updateCachedToken(token, tokenizer, stack, input)\n        token.mask = mask\n        token.context = context\n      }\n\n      if (token.value != Term.Err) {\n        let startIndex = actionIndex\n        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex)\n        actionIndex = this.addActions(stack, token.value, token.end, actionIndex)\n        if (!tokenizer.extend) {\n          main = token\n          if (actionIndex > startIndex) break\n        }\n      }\n    }\n\n    while (this.actions.length > actionIndex) this.actions.pop()\n    if (!main) {\n      main = dummyToken\n      main.start = stack.pos\n      if (stack.pos == input.length) main.accept(stack.p.parser.eofTerm, stack.pos)\n      else main.accept(Term.Err, stack.pos + 1)\n    }\n    this.mainToken = main\n    return this.actions\n  }\n\n  updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: Input) {\n    token.clear(stack.pos)\n    tokenizer.token(input, token, stack)\n    if (token.value > -1) {\n      let {parser} = stack.p\n\n      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {\n        let result = parser.specializers[i](input.read(token.start, token.end), stack)\n        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n          if ((result & 1) == Specialize.Specialize) token.value = result >> 1\n          else token.extended = result >> 1\n          break\n        }\n      }\n    } else if (stack.pos == input.length) {\n      token.accept(stack.p.parser.eofTerm, stack.pos)\n    } else {\n      token.accept(Term.Err, stack.pos + 1)\n    }\n  }\n\n  putAction(action: number, token: number, end: number, index: number) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index\n    this.actions[index++] = action\n    this.actions[index++] = token\n    this.actions[index++] = end\n    return index\n  }\n\n  addActions(stack: Stack, token: number, end: number, index: number) {\n    let {state} = stack, {parser} = stack.p, {data} = parser\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? ParseState.Skip : ParseState.Actions);; i += 3) {\n        if (data[i] == Seq.End) {\n          if (data[i + 1] == Seq.Next) {\n            i = pair(data, i + 2)\n          } else {\n            if (index == 0 && data[i + 1] == Seq.Other)\n              index = this.putAction(pair(data, i + 1), token, end, index)\n            break\n          }\n        }\n        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index)\n      }\n    }\n    return index\n  }\n}\n\nconst enum Rec {\n  Distance = 5,\n  MaxRemainingPerStep = 3,\n  MinBufferLengthPrune = 200,\n  ForceReduceLimit = 10\n}\n\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nexport class Parse implements PartialParse {\n  // Active parse stacks.\n  stacks: Stack[]\n  // The position to which the parse has advanced.\n  pos = 0\n  recovering = 0\n  fragments: FragmentCursor | null\n  nextStackID = 0x2654\n  nested: PartialParse | null = null\n  nestEnd = 0\n  nestWrap: NodeType | null = null\n\n  reused: (Tree | TreeBuffer)[] = []\n  tokens: TokenCache\n  topTerm: number\n\n  constructor(\n    public parser: Parser,\n    public input: Input,\n    public startPos: number,\n    public context: ParseContext\n  ) {\n    this.tokens = new TokenCache(parser)\n    this.topTerm = parser.top[1]\n    this.stacks = [Stack.start(this, parser.top[0], this.startPos)]\n    let fragments = context?.fragments\n    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null\n  }\n\n  // Move the parser forward. This will process all parse stacks at\n  // `this.pos` and try to advance them to a further position. If no\n  // stack for such a position is found, it'll start error-recovery.\n  //\n  // When the parse is finished, this will return a syntax tree. When\n  // not, it returns `null`.\n  advance() {\n    if (this.nested) {\n      let result = this.nested.advance()\n      this.pos = this.nested.pos\n      if (result) {\n        this.finishNested(this.stacks[0], result)\n        this.nested = null\n      }\n      return null\n    }\n\n    let stacks = this.stacks, pos = this.pos\n    // This will hold stacks beyond `pos`.\n    let newStacks: Stack[] = this.stacks = []\n    let stopped: Stack[] | undefined, stoppedTokens: number[] | undefined\n    let maybeNest\n\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], nest\n      for (;;) {\n        if (stack.pos > pos) {\n          newStacks.push(stack)\n        } else if (nest = this.checkNest(stack)) {\n          if (!maybeNest || maybeNest.stack.score < stack.score) maybeNest = nest\n        } else if (this.advanceStack(stack, newStacks, stacks)) {\n          continue\n        } else {\n          if (!stopped) { stopped = []; stoppedTokens = [] }\n          stopped.push(stack)\n          let tok = this.tokens.mainToken\n          stoppedTokens!.push(tok.value, tok.end)\n        }\n        break\n      }\n    }\n\n    if (maybeNest) {\n      this.startNested(maybeNest)\n      return null\n    }\n\n    if (!newStacks.length) {\n      let finished = stopped && findFinished(stopped)\n      if (finished) return this.stackToTree(finished)\n\n      if (this.parser.strict) {\n        if (verbose && stopped)\n          console.log(\"Stuck with token \" + this.parser.getName(this.tokens.mainToken.value))\n        throw new SyntaxError(\"No parse at \" + pos)\n      }\n      if (!this.recovering) this.recovering = Rec.Distance\n    }\n\n    if (this.recovering && stopped) {\n      let finished = this.runRecovery(stopped, stoppedTokens!, newStacks)\n      if (finished) return this.stackToTree(finished.forceAll())\n    }\n\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * Rec.MaxRemainingPerStep\n      if (newStacks.length > maxRemaining) {\n        newStacks.sort((a, b) => b.score - a.score)\n        while (newStacks.length > maxRemaining) newStacks.pop()\n      }\n      if (newStacks.some(s => s.reducePos > pos)) this.recovering--\n    } else if (newStacks.length > 1) {\n      // Prune stacks that are in the same state, or that have been\n      // running without splitting for a while, to avoid getting stuck\n      // with multiple successful stacks running endlessly on.\n      outer: for (let i = 0; i < newStacks.length - 1; i++) {\n        let stack = newStacks[i]\n        for (let j = i + 1; j < newStacks.length; j++) {\n          let other = newStacks[j]\n          if (stack.sameState(other) ||\n              stack.buffer.length > Rec.MinBufferLengthPrune && other.buffer.length > Rec.MinBufferLengthPrune) {\n            if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n              newStacks.splice(j--, 1)\n            } else {\n              newStacks.splice(i--, 1)\n              continue outer\n            }\n          }\n        }\n      }\n    }\n\n    this.pos = newStacks[0].pos\n    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.pos) this.pos = newStacks[i].pos\n    return null\n  }\n\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` and `stacks` are\n  // given, stacks split off by ambiguous operations will be pushed to\n  // `split`, or added to `stacks` if they move `pos` forward.\n  private advanceStack(stack: Stack, stacks: null | Stack[], split: null | Stack[]) {\n    let start = stack.pos, {input, parser} = this\n    let base = verbose ? this.stackID(stack) + \" -> \" : \"\"\n\n    if (this.fragments) {\n      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext!.hash : 0\n      for (let cached = this.fragments.nodeAt(start); cached;) {\n        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1\n        if (match > -1 && cached.length && (!strictCx || ((cached as any).contextHash || 0) == cxHash)) {\n          stack.useNode(cached, match)\n          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`)\n          return true\n        }\n        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break\n        let inner = cached.children[0]\n        if (inner instanceof Tree) cached = inner\n        else break\n      }\n    }\n\n    let defaultReduce = parser.stateSlot(stack.state, ParseState.DefaultReduce)\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce)\n      if (verbose)\n        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & Action.ValueMask)})`)\n      return true\n    }\n\n    let actions = this.tokens.getActions(stack, input)\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++], term = actions[i++], end = actions[i++]\n      let last = i == actions.length || !split\n      let localStack = last ? stack : stack.split()\n      localStack.apply(action, term, end)\n      if (verbose)\n        console.log(base + this.stackID(localStack) + ` (via ${(action & Action.ReduceFlag) == 0 ? \"shift\"\n                     : `reduce of ${parser.getName(action & Action.ValueMask)}`} for ${\n        parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`)\n      if (last) return true\n      else if (localStack.pos > start) stacks!.push(localStack)\n      else split!.push(localStack)\n    }\n\n    return false\n  }\n\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `pushStackDedup`.\n  private advanceFully(stack: Stack, newStacks: Stack[]) {\n    let pos = stack.pos\n    for (;;) {\n      let nest = this.checkNest(stack)\n      if (nest) return nest\n      if (!this.advanceStack(stack, null, null)) return false\n      if (stack.pos > pos) {\n        pushStackDedup(stack, newStacks)\n        return true\n      }\n    }\n  }\n\n  private runRecovery(stacks: Stack[], tokens: number[], newStacks: Stack[]) {\n    let finished: Stack | null = null, restarted = false\n    let maybeNest\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1]\n      let base = verbose ? this.stackID(stack) + \" -> \" : \"\"\n\n      if (stack.deadEnd) {\n        if (restarted) continue\n        restarted = true\n        stack.restart()\n        if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\")\n        let done = this.advanceFully(stack, newStacks)\n        if (done) {\n          if (done !== true) maybeNest = done\n          continue\n        }\n      }\n\n      let force = stack.split(), forceBase = base\n      for (let j = 0; force.forceReduce() && j < Rec.ForceReduceLimit; j++) {\n        if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\")\n        let done = this.advanceFully(force, newStacks)\n        if (done) {\n          if (done !== true) maybeNest = done\n          break\n        }\n        if (verbose) forceBase = this.stackID(force) + \" -> \"\n      }\n\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\")\n        this.advanceFully(insert, newStacks)\n      }\n\n      if (this.input.length > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++\n          token = Term.Err\n        }\n        stack.recoverByDelete(token, tokenEnd)\n        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`)\n        pushStackDedup(stack, newStacks)\n      } else if (!finished || finished.score < stack.score) {\n        finished = stack\n      }\n    }\n\n    if (finished) return finished\n\n    if (maybeNest) for (let s of this.stacks) if (s.score > maybeNest.stack.score) {\n      maybeNest = undefined\n      break\n    }\n    if (maybeNest) this.startNested(maybeNest)\n    return null\n  }\n\n  forceFinish() {\n    let stack = this.stacks[0].split()\n    if (this.nested) this.finishNested(stack, this.nested.forceFinish())\n    return this.stackToTree(stack.forceAll())\n  }\n\n  // Convert the stack's buffer to a syntax tree.\n  stackToTree(stack: Stack, pos: number = stack.pos): Tree {\n    if (this.parser.context) stack.emitContext()\n    return Tree.build({buffer: StackBufferCursor.create(stack),\n                       nodeSet: this.parser.nodeSet,\n                       topID: this.topTerm,\n                       maxBufferLength: this.parser.bufferLength,\n                       reused: this.reused,\n                       start: this.startPos,\n                       length: pos - this.startPos,\n                       minRepeatType: this.parser.minRepeatTerm})\n  }\n\n  private checkNest(stack: Stack) {\n    let info = this.parser.findNested(stack.state)\n    if (!info) return null\n    let spec: NestedParser | null = info.value\n    if (typeof spec == \"function\") spec = spec(this.input, stack)\n    return spec ? {stack, info, spec} : null\n  }\n\n  private startNested(nest: {stack: Stack, info: NestInfo, spec: NestedParserSpec}) {\n    let {stack, info, spec} = nest\n    this.stacks = [stack]\n    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd)\n    this.nestWrap = typeof spec.wrapType == \"number\" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null\n    if (spec.startParse) {\n      this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context)\n    } else {\n      this.finishNested(stack)\n    }\n  }\n\n  private scanForNestEnd(stack: Stack, endToken: TokenGroup, filter?: (token: string) => boolean) {\n    for (let pos = stack.pos; pos < this.input.length; pos++) {\n      dummyToken.start = pos\n      dummyToken.value = -1\n      endToken.token(this.input, dummyToken, stack)\n      if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end)))) return pos\n    }\n    return this.input.length\n  }\n\n  private finishNested(stack: Stack, tree?: Tree) {\n    if (this.nestWrap) tree = new Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos)\n    else if (!tree) tree = new Tree(NodeType.none, [], [], this.nestEnd - stack.pos)\n    let info = this.parser.findNested(stack.state)!\n    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true))\n    if (verbose) console.log(this.stackID(stack) + ` (via unnest)`)\n  }\n\n  private stackID(stack: Stack) {\n    let id = (stackIDs || (stackIDs = new WeakMap)).get(stack)\n    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++))\n    return id + stack\n  }\n}\n\nfunction pushStackDedup(stack: Stack, newStacks: Stack[]) {\n  for (let i = 0; i < newStacks.length; i++) {\n    let other = newStacks[i]\n    if (other.pos == stack.pos && other.sameState(stack)) {\n      if (newStacks[i].score < stack.score) newStacks[i] = stack\n      return\n    }\n  }\n  newStacks.push(stack)\n}\n\nexport class Dialect {\n  constructor(readonly source: string | undefined,\n              readonly flags: readonly boolean[],\n              readonly disabled: null | Uint8Array) {}\n\n  allows(term: number) { return !this.disabled || this.disabled[term] == 0 }\n}\n\nconst id: <T>(x: T) => T = x => x\n\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\nexport class ContextTracker<T> {\n  /// @internal\n  start: T\n  /// @internal\n  shift: (context: T, term: number, input: Input, stack: Stack) => T\n  /// @internal\n  reduce: (context: T, term: number, input: Input, stack: Stack) => T\n  /// @internal\n  reuse: (context: T, node: Tree | TreeBuffer, input: Input, stack: Stack) => T\n  /// @internal\n  hash: (context: T) => number\n  /// @internal\n  strict: boolean\n\n  /// The export used in a `@context` declaration should be of this\n  /// type.\n  constructor(spec: {\n    /// The initial value of the context.\n    start: T,\n    /// Update the context when the parser executes a\n    /// [shift](https://en.wikipedia.org/wiki/LR_parser#Shift_and_reduce_actions)\n    /// action.\n    shift?(context: T, term: number, input: Input, stack: Stack): T\n    /// Update the context when the parser executes a reduce action.\n    reduce?(context: T, term: number, input: Input, stack: Stack): T\n    /// Update the context when the parser reuses a node from a tree\n    /// fragment.\n    reuse?(context: T, node: Tree | TreeBuffer, input: Input, stack: Stack): T\n    /// Reduce a context value to a number (for cheap storage and\n    /// comparison).\n    hash(context: T): number\n    /// By default, nodes can only be reused during incremental\n    /// parsing if they were created in the same context as the one in\n    /// which they are reused. Set this to false to disable that\n    /// check.\n    strict?: boolean\n  }) {\n    this.start = spec.start\n    this.shift = spec.shift || id\n    this.reduce = spec.reduce || id\n    this.reuse = spec.reuse || id\n    this.hash = spec.hash\n    this.strict = spec.strict !== false\n  }\n}\n\ntype ParserSpec = {\n  version: number,\n  states: string | Uint32Array,\n  stateData: string | Uint16Array,\n  goto: string | Uint16Array,\n  nodeNames: string,\n  maxTerm: number,\n  repeatNodeCount: number,\n  nodeProps?: [NodeProp<any>, ...(string | number)[]][],\n  skippedNodes?: number[],\n  tokenData: string,\n  tokenizers: (Tokenizer | number)[],\n  topRules: {[name: string]: [number, number]},\n  context: ContextTracker<any> | null,\n  nested?: [string, NestedParser, string | Uint16Array, number][],\n  dialects?: {[name: string]: number},\n  dynamicPrecedences?: {[term: number]: number},\n  specialized?: {term: number, get: (value: string, stack: Stack) => number}[],\n  tokenPrec: number,\n  termNames?: {[id: number]: string}\n}\n\ntype NestInfo = {\n  // A name, used by `withNested`\n  name: string,\n  value: NestedParser,\n  // A token-recognizing automaton for the end of the nesting\n  end: TokenGroup,\n  // The id of the placeholder term that appears in the grammar at\n  // the position of this nesting\n  placeholder: number\n}\n\n/// Configuration options to pass to a parser.\nexport interface ParserConfig {\n  /// Node props to add to the parser's node set.\n  props?: readonly NodePropSource[],\n  /// The name of the @top declaration to parse from. If not\n  /// specified, the first @top declaration is used.\n  top?: string,\n  /// A space-separated string of dialects to enable.\n  dialect?: string,\n  /// The nested grammars to use. This can be used to, for example,\n  /// swap in a different language for a nested grammar or fill in a\n  /// nested grammar that was left blank by the original grammar.\n  nested?: {[name: string]: NestedParser},\n  /// Replace the given external tokenizers with new ones.\n  tokenizers?: {from: ExternalTokenizer, to: ExternalTokenizer}[],\n  /// When true, the parser will raise an exception, rather than run\n  /// its error-recovery strategies, when the input doesn't match the\n  /// grammar.\n  strict?: boolean\n  /// The maximum length of the TreeBuffers generated in the output\n  /// tree. Defaults to 1024.\n  bufferLength?: number\n}\n\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nexport class Parser {\n  /// The parse states for this grammar @internal\n  readonly states: Readonly<Uint32Array>\n  /// A blob of data that the parse states, as well as some\n  /// of `Parser`'s fields, point into @internal\n  readonly data: Readonly<Uint16Array>\n  /// The goto table. See `computeGotoTable` in\n  /// lezer-generator for details on the format @internal\n  readonly goto: Readonly<Uint16Array>\n  /// A node set with the node types used by this parser.\n  readonly nodeSet: NodeSet\n  /// The highest term id @internal\n  readonly maxTerm: number\n  /// The first repeat-related term id @internal\n  readonly minRepeatTerm: number\n  /// The tokenizer objects used by the grammar @internal\n  readonly tokenizers: readonly Tokenizer[]\n  /// Maps top rule names to [state ID, top term ID] pairs. @internal\n  readonly topRules: {[name: string]: [number, number]}\n  /// @internal\n  readonly context: ContextTracker<unknown> | null\n  /// Metadata about nested grammars used in this grammar @internal\n  readonly nested: readonly NestInfo[]\n  /// A mapping from dialect names to the tokens that are exclusive\n  /// to them. @internal\n  readonly dialects: {[name: string]: number}\n  /// Null if there are no dynamic precedences, a map from term ids\n  /// to precedence otherwise. @internal\n  readonly dynamicPrecedences: {[term: number]: number} | null\n  /// The token types have specializers (in this.specializers) @internal\n  readonly specialized: Uint16Array\n  /// The specializer functions for the token types in specialized @internal\n  readonly specializers: ((value: string, stack: Stack) => number)[]\n  /// Points into this.data at an array that holds the\n  /// precedence order (higher precedence first) for ambiguous\n  /// tokens @internal\n  readonly tokenPrecTable: number\n  /// An optional object mapping term ids to name strings @internal\n  readonly termNames: null | {[id: number]: string}\n  /// @internal\n  readonly maxNode: number\n  /// @internal\n  readonly dialect: Dialect\n  /// @internal\n  readonly top: [number, number]\n  /// @internal\n  readonly bufferLength = DefaultBufferLength\n  /// @internal\n  readonly strict = false\n\n  private cachedDialect: Dialect | null = null\n\n  /// @internal\n  constructor(spec: ParserSpec) {\n    if (spec.version != File.Version)\n      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${File.Version})`)\n    let tokenArray = decodeArray<Uint16Array>(spec.tokenData)\n    let nodeNames = spec.nodeNames.split(\" \")\n    this.minRepeatTerm = nodeNames.length\n    this.context = spec.context\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\")\n    let nodeProps: [NodeProp<any>, any][][] = []\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([])\n    function setProp(nodeID: number, prop: NodeProp<any>, value: any) {\n      nodeProps[nodeID].push([prop, prop.deserialize(String(value))])\n    }\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0]\n      for (let i = 1; i < propSpec.length;) {\n        let next = propSpec[i++]\n        if (next >= 0) {\n          setProp(next as number, prop, propSpec[i++] as string)\n        } else {\n          let value = propSpec[i + -next] as string\n          for (let j = -next; j > 0; j--) setProp(propSpec[i++] as number, prop, value)\n          i++\n        }\n      }\n    }\n    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0)\n    this.specializers = []\n    if (spec.specialized) for (let i = 0; i < spec.specialized.length; i++) {\n      this.specialized[i] = spec.specialized[i].term\n      this.specializers[i] = spec.specialized[i].get\n    }\n\n    this.states = decodeArray(spec.states, Uint32Array)\n    this.data = decodeArray(spec.stateData)\n    this.goto = decodeArray(spec.goto)\n    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1])\n    this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n      name: i >= this.minRepeatTerm ? undefined: name,\n      id: i,\n      props: nodeProps[i],\n      top: topTerms.indexOf(i) > -1,\n      error: i == 0,\n      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n    })))\n    this.maxTerm = spec.maxTerm\n    this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value)\n    this.topRules = spec.topRules\n    this.nested = (spec.nested || []).map(([name, value, endToken, placeholder]) => {\n      return {name, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder}\n    })\n    this.dialects = spec.dialects || {}\n    this.dynamicPrecedences = spec.dynamicPrecedences || null\n    this.tokenPrecTable = spec.tokenPrec\n    this.termNames = spec.termNames || null\n    this.maxNode = this.nodeSet.types.length - 1\n\n    this.dialect = this.parseDialect()\n    this.top = this.topRules[Object.keys(this.topRules)[0]]\n  }\n\n  /// Parse a given string or stream.\n  parse(input: Input | string, startPos: number = 0, context: ParseContext = {}) {\n    if (typeof input == \"string\") input = stringInput(input)\n    let cx = new Parse(this, input, startPos, context)\n    for (;;) {\n      let done = cx.advance()\n      if (done) return done\n    }\n  }\n\n  /// Start an incremental parse.\n  startParse(input: Input | string, startPos: number = 0, context: ParseContext = {}): PartialParse {\n    if (typeof input == \"string\") input = stringInput(input)\n    return new Parse(this, input, startPos, context)\n  }\n\n  /// Get a goto table entry @internal\n  getGoto(state: number, term: number, loose = false) {\n    let table = this.goto\n    if (term >= table[0]) return -1\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++], last = groupTag & 1\n      let target = table[pos++]\n      if (last && loose) return target\n      for (let end = pos + (groupTag >> 1); pos < end; pos++)\n        if (table[pos] == state) return target\n      if (last) return -1\n    }\n  }\n\n  /// Check if this state has an action for a given terminal @internal\n  hasAction(state: number, terminal: number) {\n    let data = this.data\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next;; i += 3) {\n        if ((next = data[i]) == Seq.End) {\n          if (data[i + 1] == Seq.Next) next = data[i = pair(data, i + 2)]\n          else if (data[i + 1] == Seq.Other) return pair(data, i + 2)\n          else break\n        }\n        if (next == terminal || next == Term.Err) return pair(data, i + 1)\n      }\n    }\n    return 0\n  }\n\n  /// @internal\n  stateSlot(state: number, slot: number) {\n    return this.states[(state * ParseState.Size) + slot]\n  }\n\n  /// @internal\n  stateFlag(state: number, flag: number) {\n    return (this.stateSlot(state, ParseState.Flags) & flag) > 0\n  }\n\n  /// @internal\n  findNested(state: number) {\n    let flags = this.stateSlot(state, ParseState.Flags)\n    return flags & StateFlag.StartNest ? this.nested[flags >> StateFlag.NestShift] : null\n  }\n\n  /// @internal\n  validAction(state: number, action: number) {\n    if (action == this.stateSlot(state, ParseState.DefaultReduce)) return true\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) {\n        if (this.data[i + 1] == Seq.Next) i = pair(this.data, i + 2)\n        else return false\n      }\n      if (action == pair(this.data, i + 1)) return true\n    }\n  }\n\n  /// Get the states that can follow this one through shift actions or\n  /// goto jumps. @internal\n  nextStates(state: number): readonly number[] {\n    let result: number[] = []\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) {\n        if (this.data[i + 1] == Seq.Next) i = pair(this.data, i + 2)\n        else break\n      }\n      if ((this.data[i + 2] & (Action.ReduceFlag >> 16)) == 0) {\n        let value = this.data[i + 1]\n        if (!result.some((v, i) => (i & 1) && v == value)) result.push(this.data[i], value)\n      }\n    }\n    return result\n  }\n\n  /// @internal\n  overrides(token: number, prev: number) {\n    let iPrev = findOffset(this.data, this.tokenPrecTable, prev)\n    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev\n  }\n\n  /// Configure the parser. Returns a new parser instance that has the\n  /// given settings modified. Settings not provided in `config` are\n  /// kept from the original parser.\n  configure(config: ParserConfig) {\n    // Hideous reflection-based kludge to make it easy to create a\n    // slightly modified copy of a parser.\n    let copy = Object.assign(Object.create(Parser.prototype), this)\n    if (config.props)\n      copy.nodeSet = this.nodeSet.extend(...config.props)\n    if (config.top) {\n      let info = this.topRules[config.top!]\n      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`)\n      copy.top = info\n    }\n    if (config.tokenizers)\n      copy.tokenizers = this.tokenizers.map(t => {\n        let found = config.tokenizers!.find(r => r.from == t)\n        return found ? found.to : t\n      })\n    if (config.dialect)\n      copy.dialect = this.parseDialect(config.dialect)\n    if (config.nested)\n      copy.nested = this.nested.map(obj => {\n        if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name)) return obj\n        return {name: obj.name, value: config.nested![obj.name], end: obj.end, placeholder: obj.placeholder}\n      })\n    if (config.strict != null)\n      copy.strict = config.strict\n    if (config.bufferLength != null)\n      copy.bufferLength = config.bufferLength\n    return copy as Parser\n  }\n\n  /// Returns the name associated with a given term. This will only\n  /// work for all terms when the parser was generated with the\n  /// `--names` option. By default, only the names of tagged terms are\n  /// stored.\n  getName(term: number): string {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term)\n  }\n\n  /// The eof term id is always allocated directly after the node\n  /// types. @internal\n  get eofTerm() { return this.maxNode + 1 }\n\n  /// Tells you whether this grammar has any nested grammars.\n  get hasNested() { return this.nested.length > 0 }\n\n  /// The type of top node produced by the parser.\n  get topNode() { return this.nodeSet.types[this.top[1]] }\n\n  /// @internal\n  dynamicPrecedence(term: number) {\n    let prec = this.dynamicPrecedences\n    return prec == null ? 0 : prec[term] || 0\n  }\n\n  /// @internal\n  parseDialect(dialect?: string) {\n    if (this.cachedDialect && this.cachedDialect.source == dialect) return this.cachedDialect\n    let values = Object.keys(this.dialects), flags = values.map(() => false)\n    if (dialect) for (let part of dialect.split(\" \")) {\n      let id = values.indexOf(part)\n      if (id >= 0) flags[id] = true\n    }\n    let disabled: Uint8Array | null = null\n    for (let i = 0; i < values.length; i++) if (!flags[i]) {\n      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != Seq.End;)\n        (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1\n    }\n    return this.cachedDialect = new Dialect(dialect, flags, disabled)\n  }\n\n  /// (used by the output of the parser generator) @internal\n  static deserialize(spec: ParserSpec) {\n    return new Parser(spec)\n  }\n}\n\nfunction pair(data: Readonly<Uint16Array>, off: number) { return data[off] | (data[off + 1] << 16) }\n\nfunction findOffset(data: Readonly<Uint16Array>, start: number, term: number) {\n  for (let i = start, next; (next = data[i]) != Seq.End; i++)\n    if (next == term) return i - start\n  return -1\n}\n\nfunction findFinished(stacks: Stack[]) {\n  let best: Stack | null = null\n  for (let stack of stacks) {\n    if (stack.pos == stack.p.input.length &&\n        stack.p.parser.stateFlag(stack.state, StateFlag.Accepting) &&\n        (!best || best.score < stack.score))\n      best = stack\n  }\n  return best\n}\n"],
  "mappings": "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",
  "names": ["id", "children", "positions", "buffer", "data", "i", "Recover", "id", "Rec"]
}
